# Множество Мандельброта

## Описание задачи 

 Множество Мандельброта — это совокупность
всех чисел c ∈ C, для которых последовательность
$z_{n+1} = z^2_n + c$
является ограниченной для всех значений $n ∈ N$. Иными словами, число
c принадлежит множеству Мандельброта тогда и только тогда, когда
$(∃A ∈ R)$ $(∀n ∈ N)$ $|z_n| < A$
Можно доказать, что в последнем равенстве A можно взять равным
двум, т.е. число c принадлежит множеству Мандельброта тогда и только
тогда, когда
$(∀n ∈ N)$ $|z_n| < 2$, $z_1 = 0$

## Формат входных данных 

Формат входных данных. Запуск программы из командной строки
***./program nthreads npoints***,
где ***nthreads*** — количество потоков,
***npoints*** — количество точек, которые проверяем на принадлженость к множеству мандельброта.

## Формат выходных данных

Файл формата *csv* с координатами точек множества Мандельброта.

# Отчет

Один из примеров результатов работы можно посмотреть в файле [points.csv](https://github.com/Max-Size/distributed_calculations/blob/main/lab_1/mandelbrot/points.csv) и соответсвующим данному набору точек получившемуся графику ![mandelbrot.png](https://raw.githubusercontent.com/Max-Size/distributed_calculations/refs/heads/main/lab_1/mandelbrot/mandelbrot.png)

Ниже представлены замеры времени при различных параметрах 

| nthreads \ ntrials | 1000     |  5000    |  10000   |  30000   | 50000     | 100000   | 200000    | 500000   | 1000000  |
| ------             | ------   | ------   | ------   | ------   | ------    | ------   | ------    | ------   | ------   | 
| 1                  | 0.007398 | 0.028624 | 0.058261 | 0.169265 | 0.276778  | 0.552063 | 1.136135  | 2.777774 | 5.528575 |
| 2                  | 0.007423 | 0.021690 | 0.041119 | 0.126838 | 0.204368  | 0.401915 | 0.815890  | 2.048598 | 4.060817 |
| 3                  | 0.005961 | 0.019806 | 0.036761 | 0.108246 | 0.188311  | 0.364562 | 0.726147  | 1.833757 | 3.636241 |
| 4                  | 0.005600 | 0.021656 | 0.041883 | 0.107259 | 0.183845  | 0.363399 | 0.718335  | 1.787433 | 3.586473 |
| 5                  | 0.005296 | 0.014847 | 0.029574 | 0.082683 | 0.136716  | 0.267589 | 0.532526  | 1.348241 | 2.649310 |
| 6                  | 0.005510 | 0.014272 | 0.025333 | 0.077828 | 0.134931  | 0.255663 | 0.510160  | 1.291463 | 2.541991 |
| 7                  | 0.004369 | 0.012549 | 0.024687 | 0.069256 | 0.114359  | 0.226161 | 0.460043  | 1.157145 | 2.261376 |
| 8                  | 0.004997 | 0.013488 | 0.022646 | 0.063080 | 0.101689  | 0.192436 | 0.388714  | 0.953633 | 1.884147 |

Ускорение

| nthreads \ ntrials | 1000     |  5000    |  10000   |  30000   | 50000     | 100000   | 200000    | 500000   | 1000000  |
| ------             | ------   | ------   | ------   | ------   | ------    | ------   | ------    | ------   | ------   | 
| 2                  | 0.996632 | 1.319686 | 1.416888 | 1.334498 | 1.354312  | 1.373581 | 1.392510  | 1.355939 | 1.361444 |
| 3                  | 1.241067 | 1.445219 | 1.584859 | 1.563707 | 1.469792  | 1.514319 | 1.564607  | 1.514799 | 1.520409 |
| 4                  | 1.321071 | 1.321758 | 1.391042 | 1.578096 | 1.505496  | 1.519165 | 1.581623  | 1.554058 | 1.541507 |
| 5                  | 1.396903 | 1.927932 | 1.970007 | 2.047156 | 2.024474  | 2.063101 | 2.133483  | 2.060295 | 2.086798 |
| 6                  | 1.342650 | 2.005605 | 2.299807 | 2.174860 | 2.051256  | 2.159339 | 2.227017  | 2.150874 | 2.174900 |
| 7                  | 1.693294 | 2.280979 | 2.359987 | 2.444048 | 2.420256  | 2.441018 | 2.469628  | 2.400540 | 2.444783 |
| 8                  | 1.480488 | 2.122183 | 2.572684 | 2.683339 | 2.721809  | 2.868814 | 2.922804  | 2.912833 | 2.934259 |

Эффективность

| nthreads \ ntrials | 1000     |  5000    |  10000   |  30000   | 50000     | 100000   | 200000    | 500000   | 1000000  |
| ------             | ------   | ------   | ------   | ------   | ------    | ------   | ------    | ------   | ------   | 
| 2                  | 0.498316 | 0.659843 | 0.708444 | 0.667249 | 0.677156  | 0.686790 | 0.696255  | 0.677970 | 0.680722 |
| 3                  | 0.413689 | 0.481740 | 0.528286 | 0.521236 | 0.489931  | 0.504773 | 0.521536  | 0.504933 | 0.506803 |
| 4                  | 0.330268 | 0.330439 | 0.347760 | 0.394524 | 0.376374  | 0.379791 | 0.395406  | 0.388514 | 0.385377 |
| 5                  | 0.279381 | 0.385586 | 0.394001 | 0.409431 | 0.404895  | 0.412620 | 0.426697  | 0.412059 | 0.417360 |
| 6                  | 0.223775 | 0.334267 | 0.383301 | 0.362477 | 0.341876  | 0.359890 | 0.371169  | 0.358479 | 0.362483 |
| 7                  | 0.241899 | 0.325854 | 0.337141 | 0.349150 | 0.345751  | 0.348717 | 0.352804  | 0.342934 | 0.349255 |
| 8                  | 0.185061 | 0.265273 | 0.321586 | 0.335417 | 0.340226  | 0.358602 | 0.365351  | 0.364104 | 0.366782 |

Ради эксперимента были протестированы 2 варианта записи точек в файл:

1) Который используется в основном коде программмы
```C
void write_points_in_file(double *real, double *image, int count)
{
    pthread_mutex_lock(&mutex);
    for (int i = 0; i < count; i++)
    {
        fprintf(file, "%f, %f\n", real[i], image[i]);
    }
    pthread_mutex_unlock(&mutex);
}
```

2) 

```C
void write_points_in_file(double *real, double *image, int count)
{
    for (int i = 0; i < count; i++)
    {   
        pthread_mutex_lock(&mutex);
        fprintf(file, "%f, %f\n", real[i], image[i]);
        pthread_mutex_unlock(&mutex);
    }   
}
```

Различия лишь в том, в какой момент мы лочим мьютекс: либо снаружи цикла, и в цикле уже спокойно записываем точки; либо записываем точки поочередно. В итоге получилось что разница в принципе отсутвует, потому что и в том и в другом случае по сути происходит последовательная запись данных в файл. В данной задаче распараллелить получается лишь сам процесс определения точек, но их запись в файл, увы, никак.

Также стоит обратить внимание что как и в случае задачи вычисления числа Пи, алгоритм малоэффективен для небольшого кол-ва данных для вычисления и большого кол-ва потоков, так как игра не стоит свеч, и создание потоков в данном случае занимает весомую часть времени от работы всей программы, но все же 1.5 раза быстрее чем на одном потоке. 